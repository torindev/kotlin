package chapter_5

fun run5_3() {
    val someMap = mapOf(
        Pair("name1", 12),
        Pair("name2", 13),
        Pair("name3", 14),
        Pair("name4", 15),
        Pair("name5", 16),
        Pair("name6", 17),
        Pair("name7", 18),
        Pair("name8", 19),
        Pair("name9", 20)
    )

    // Способ обхода коллекции #1
    // в таком случае filter пройдет все элементы, создаст промежуточную коллекцию, и после этого map
    // преобразует те элементы что < 16 в лист Int
    val result1 = someMap.filter { it.value < 16 }.map { it.value * 2 }
    println("result1 size = ${result1.size}")


    // Способ обхода #2
    // Данный способ обрабатывает элементы по одной штуке и не создает промежуточных коллеций, как первый способ
    // рекомендуется использовать такой подход, если работа идет с большими коллекциями на тычсячи элементов
    // в Данном способе метод toList() это триггер, который запускает выполнение операции,
    // если его добавить, лист с резулттатами не ьудет получен
    // Еще одно отличие в том, что этот способ не будет обходить все элементы с помозью filter, а остановится там где значение не
    // будет удавлетворено условию
    val result2 = someMap
        .asSequence() // преобразует в последовательность (значит обрабатываем по одному элементу, не создавая новую коллекцию)
        .filter { it.value < 16 }
        .map { it.value * 2 }
        .toList() // триггер для запуска операции, без него не удет результата
    println("result2 size = ${result2.size}")

    //так же последовательности можно генерировать
    val naturalNumbersSeq = generateSequence(0) { it + 1 }
    val numTo100 = naturalNumbersSeq.takeWhile { it <= 1000 }
    println("sum = ${numTo100.sum()}")
}